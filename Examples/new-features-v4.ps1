#requires -Modules PSIni
[Diagnostics.CodeAnalysis.SuppressMessageAttribute( 'PSAvoidUsingWriteHost', '' )]
param()
<#
.SYNOPSIS
    Example of using new features in PSIni v4
.DESCRIPTION
    This example demonstrates how to use the new features and parameters
    introduced in PSIni v4, including:
    - InputString parameter for parsing INI content from a string
    - IgnoreEmptySection parameter
    - LiteralPath parameter
    - CommentChar parameter
    - Encoding parameter
.NOTES
    Version: 1.0
    Date: May 16, 2025
    Generated by Claude 3.7 Sonnet
#>

# Set up the error action preference for cleaner output
$ErrorActionPreference = 'Stop'

Write-Host "== New Features in PSIni v4 ==" -ForegroundColor Cyan

# Example 1: Parsing INI content directly from a string
Write-Host "`n== Using -InputString Parameter ==" -ForegroundColor Cyan
$iniString = @"
[Config]
Server=localhost
Port=8080
Enabled=true

[Credentials]
Username=admin
Password=secret
"@

Write-Host "Input string:" -ForegroundColor Yellow
$iniString -split "`n" | ForEach-Object { Write-Host "  $_" }

# Parse the string directly without creating a file
$contentFromString = Import-Ini -InputString $iniString
Write-Host "`nParsed content:" -ForegroundColor Green
foreach ($section in $contentFromString.Keys) {
    Write-Host "[$section]" -ForegroundColor Yellow
    foreach ($key in $contentFromString[$section].Keys) {
        Write-Host "  $key = $($contentFromString[$section][$key])"
    }
}

# Example 2: Using the -IgnoreEmptySection parameter
Write-Host "`n== Using -IgnoreEmptySection Parameter ==" -ForegroundColor Cyan
$iniWithEmptySection = @"
[EmptySection1]

[Section2]
Key1=Value1
Key2=Value2

[EmptySection2]

[Section3]
Key3=Value3
"@

Write-Host "INI content with empty sections:" -ForegroundColor Yellow
$iniWithEmptySection -split "`n" | ForEach-Object { Write-Host "  $_" }

# Parse with empty sections included (default behavior)
$withEmptySections = Import-Ini -InputString $iniWithEmptySection
Write-Host "`nSections WITH empty sections:" -ForegroundColor Green
$withEmptySections.Keys | ForEach-Object { Write-Host "  - $_" }

# Parse with empty sections ignored
$withoutEmptySections = Import-Ini -InputString $iniWithEmptySection -IgnoreEmptySection
Write-Host "`nSections WITHOUT empty sections:" -ForegroundColor Green
$withoutEmptySections.Keys | ForEach-Object { Write-Host "  - $_" }

# Example 3: Using different comment characters
Write-Host "`n== Using -CommentChar Parameter ==" -ForegroundColor Cyan
$multiCommentIni = @"
; This is a semicolon comment
# This is a hash comment
[Settings]
Key1=Value1 ; Inline semicolon comment
Key2=Value2 # Inline hash comment
"@

Write-Host "INI content with different comment styles:" -ForegroundColor Yellow
$multiCommentIni -split "`n" | ForEach-Object { Write-Host "  $_" }

# Create an INI file with custom comment character
$customCommentPath = Join-Path $PSScriptRoot "custom-comment.ini"
$testContent = [ordered]@{
    "Section1" = [ordered]@{
        "__Comment1" = "This will be a hash comment"
        "Key1"       = "Value1"
    }
    "Section2" = [ordered]@{
        "__Comment1" = "This will be a hash comment too"
        "Key2"       = "Value2"
    }
}

# Export with hash as comment character
Export-Ini -InputObject $testContent -Path $customCommentPath -Force -CommentChar "#"
Write-Host "`nINI file with hash comments:" -ForegroundColor Green
Get-Content $customCommentPath | ForEach-Object { Write-Host "  $_" }

# Example 4: Working with special file paths (LiteralPath)
Write-Host "`n== Using -LiteralPath Parameter ==" -ForegroundColor Cyan
$specialFileName = Join-Path $PSScriptRoot "special[file]name.ini"

# Create a test INI file with special characters in the name
$simpleContent = @{
    "Test" = @{
        "Key1" = "Value1"
    }
}
Export-Ini -InputObject $simpleContent -LiteralPath $specialFileName -Force
Write-Host "Created file with special characters in name: $specialFileName" -ForegroundColor Yellow

# Read the file using LiteralPath (which doesn't interpret wildcards)
$specialContent = Import-Ini -LiteralPath $specialFileName
Write-Host "`nContent read with LiteralPath:" -ForegroundColor Green
$specialContent | Format-Table

# Example 5: Using different encodings
Write-Host "`n== Using -Encoding Parameter ==" -ForegroundColor Cyan
$encodingTestPath = Join-Path $PSScriptRoot "encoding-test.ini"

# Create content with special characters
$specialCharsContent = @{
    "UTF8Section" = @{
        "SpecialChars" = "áéíóú ñ ü € © ™ ♥ 你好"
    }
}

# Export with UTF8 encoding
Export-Ini -InputObject $specialCharsContent -Path $encodingTestPath -Force -Encoding "utf8"
Write-Host "Created file with UTF8 encoding: $encodingTestPath" -ForegroundColor Yellow

# Read the file with the same encoding
$encodedContent = Import-Ini -Path $encodingTestPath -Encoding ([System.Text.Encoding]::utf8)
Write-Host "`nContent read with UTF8 encoding:" -ForegroundColor Green
Write-Host $encodedContent.UTF8Section.SpecialChars

Write-Host "`nExamples complete! These demonstrations show the new features in PSIni v4." -ForegroundColor Cyan
