#requires -Modules PSIni
[Diagnostics.CodeAnalysis.SuppressMessageAttribute( 'PSAvoidUsingWriteHost', '' )]
param()
<#
.SYNOPSIS
    Comprehensive example of working with INI files using PSIni
.DESCRIPTION
    This example demonstrates a complete workflow for working with INI files:
    - Creating INI content from scratch
    - Writing content to an INI file
    - Reading content from an INI file
    - Modifying the content
    - Saving the modified content back to the file
.NOTES
    Version: 2.0
    Date: May 16, 2025
    Based on example by mklement0 (https://stackoverflow.com/a/55341293/8176975)
    Generated by Claude 3.7 Sonnet
#>

# Set up the error action preference for cleaner output
$ErrorActionPreference = 'Stop'

Write-Host "== Comprehensive PSIni Usage Example ==" -ForegroundColor Cyan

# Check if PSIni module is available and import it
try {
    Import-Module PSIni -ErrorAction Stop
    Write-Host "Successfully imported PSIni module" -ForegroundColor Green
}
catch {
    Write-Host "PSIni module not found. Attempting to install..." -ForegroundColor Yellow
    try {
        Install-Module -Name PSIni -Scope CurrentUser -Force
        Import-Module PSIni
        Write-Host "Successfully installed and imported PSIni module" -ForegroundColor Green
    }
    catch {
        Write-Host "Failed to install PSIni module. Please install it manually." -ForegroundColor Red
        Write-Host "Error: $_" -ForegroundColor Red
        return
    }
}

# Step 1: Create INI content from scratch
Write-Host "`n== Step 1: Creating INI Content ==" -ForegroundColor Cyan

# Create an ordered hashtable that will be the in-memory representation of the INI file
# Using ordered hashtables preserves the order of sections and keys
$iniContent = [ordered]@{
    # First section named 'XXX'
    XXX = [ordered]@{
        # IMPORTANT: The PSIni module only supports STRING values
        # Values of different types are converted to strings with .ToString()
        AB = '23'
        BC = '34'
    }
    # Second section named 'YYY'
    YYY = [ordered]@{
        yin  = 'foo'
        yang = 'none'
    }
}

# Display the created content
Write-Host "Created in-memory INI content:" -ForegroundColor Yellow
foreach ($section in $iniContent.Keys) {
    Write-Host "[$section]" -ForegroundColor Green
    foreach ($key in $iniContent[$section].Keys) {
        Write-Host "  $key = $($iniContent[$section][$key])"
    }
}

# Step 2: Write content to an INI file
Write-Host "`n== Step 2: Writing Content to INI File ==" -ForegroundColor Cyan

# Define the output file path
$iniFilePath = Join-Path $PSScriptRoot "full-example.ini"

# Save the content to the INI file
# -Force is only needed if an existing file must be overwritten
Export-Ini -InputObject $iniContent -Path $iniFilePath -Force

Write-Host "Content saved to: $iniFilePath" -ForegroundColor Green
Write-Host "File content:" -ForegroundColor Yellow
Get-Content $iniFilePath | ForEach-Object { Write-Host "  $_" }

# Step 3: Read content from the INI file
Write-Host "`n== Step 3: Reading Content from INI File ==" -ForegroundColor Cyan

# Read the INI file back into a new ordered hashtable
$readContent = Import-Ini -Path $iniFilePath

Write-Host "Content read from file:" -ForegroundColor Yellow
foreach ($section in $readContent.Keys) {
    Write-Host "[$section]" -ForegroundColor Green
    foreach ($key in $readContent[$section].Keys) {
        Write-Host "  $key = $($readContent[$section][$key])"
    }
}

# Step 4: Modify the content
Write-Host "`n== Step 4: Modifying the Content ==" -ForegroundColor Cyan

# Modify values using dot notation and indexing syntax
Write-Host "Making changes to the content..." -ForegroundColor Yellow

# Modify using dot notation
$readContent.XXX.AB = '12'
Write-Host "  Changed XXX.AB to '12'" -ForegroundColor Green

# Modify using indexing syntax
$readContent['YYY']['yin'] = 'bar'
Write-Host "  Changed YYY.yin to 'bar'" -ForegroundColor Green

# Remove an entry
$readContent.YYY.Remove('yang')
Write-Host "  Removed YYY.yang" -ForegroundColor Green

# Add a new section
$readContent['ZZZ'] = [ordered]@{
    'new-key'     = 'new-value'
    'another-key' = 'another-value'
}
Write-Host "  Added new section ZZZ with keys" -ForegroundColor Green

# Step 5: Save the modified content back to the file
Write-Host "`n== Step 5: Saving Modified Content ==" -ForegroundColor Cyan

# Save the modified content back to the original file
# -Force is required to replace the existing file
Export-Ini -InputObject $readContent -Path $iniFilePath -Force

Write-Host "Modified content saved to: $iniFilePath" -ForegroundColor Green
Write-Host "Updated file content:" -ForegroundColor Yellow
Get-Content $iniFilePath | ForEach-Object { Write-Host "  $_" }

# Step 6: Verification
Write-Host "`n== Step 6: Verification ==" -ForegroundColor Cyan

# Read the file again to verify changes
$verifyContent = Import-Ini -Path $iniFilePath

# Verify key changes
Write-Host "Verifying changes:" -ForegroundColor Yellow
Write-Host "  XXX.AB = $($verifyContent.XXX.AB)" -ForegroundColor Green
Write-Host "  YYY.yin = $($verifyContent.YYY.yin)" -ForegroundColor Green
Write-Host "  YYY.yang exists: $($verifyContent.YYY.Contains('yang'))" -ForegroundColor Green
Write-Host "  ZZZ section exists: $($verifyContent.Contains('ZZZ'))" -ForegroundColor Green

# Display all sections in the final INI file
Write-Host "`nFinal sections:" -ForegroundColor Yellow
$verifyContent.Keys | ForEach-Object {
    Write-Host "  [$_]" -ForegroundColor Green
    $verifyContent[$_] | Format-Table -AutoSize
}
